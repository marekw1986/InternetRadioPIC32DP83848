/*********************************************************************
 * File Name: http_net_print.c
 *
 * Provides callback headers and resolution for user's custom
 * HTTP NET Application.
 * 
 * This file is automatically generated by the MPFS Utility
 * ALL MODIFICATIONS WILL BE OVERWRITTEN BY THE MPFS GENERATOR
 *
*********************************************************************/

/*****************************************************************************
 Copyright (C) 2012-2018 Microchip Technology Inc. and its subsidiaries.

Microchip Technology Inc. and its subsidiaries.

Subject to your compliance with these terms, you may use Microchip software 
and any derivatives exclusively with Microchip products. It is your 
responsibility to comply with third party license terms applicable to your 
use of third party software (including open source software) that may 
accompany Microchip software.

THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED 
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR 
PURPOSE.

IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS 
BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE 
FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN 
ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, 
THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
*****************************************************************************/

#include "configuration.h"
#include "definitions.h" 
#include "tcpip/tcpip.h"
#include "http_net_print.h"
#include "system_config.h"
//#include "internal.h"
#include "common.h"
#include "stream_list.h"
#include "vs1003/vs1003.h"
#include "vs1003/mediainfo.h"


/****************************************************************************
  Section:
    Application Dynamic Variables processing functions.
    For easy processing and facilitating of the transfer from the old style of 
    processing the dynamic variables with pre-defined functions,
    the new dynamic variables functions maintain the old name and
    a table showing the correspondence between the dynamic variable name
    and the function that processes that variable i smaintained in this
    coming HTTP_APP_DynVarTbl[].
    Note that this is just an example.
    The application could opt for any type of proccessing it needs to do at run time.

    See http_net.h for details regarding each of these functions.
 ****************************************************************************/

extern int time_zone;

extern uint8_t is_audio_file (char* name);

TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionGetPlayCgi(TCPIP_HTTP_NET_CONN_HANDLE connHandle);
TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionGetDirJson(TCPIP_HTTP_NET_CONN_HANDLE connHandle);

TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionPostConfig(TCPIP_HTTP_NET_CONN_HANDLE connHandle);
TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionPostPlay(TCPIP_HTTP_NET_CONN_HANDLE connHandle);
TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionPostPass(TCPIP_HTTP_NET_CONN_HANDLE connHandle);

static bool is_local_url_valid(const char* url);
const char* get_altname_if_available(SYS_FS_FSTAT* stat);

enum {CFGCHANGE_UNKNOWN, CFGCHANGE_INVALID_TOKEN, CFGCHANGE_INVALID_DHCP, CFGCHANGE_INVALID_IP, CFGCHANGE_INVALID_MAC, CFGCHANGE_INVALID_NETMASK, CFGCHANGE_INVALID_GW, CFGCHANGE_INVALID_DNS1, CFGCHANGE_INVALID_DNS2, CFGCHANGE_INVALID_NTP, CFGCHANGE_INVALID_TIMEZONE, CFGCHANGE_OK};
enum {PLAY_UNKNOWN, PLAY_OK, PLAY_INVALID_TOKEN, PLAY_INVALID_URL, PLAY_INVALID_SRC};
enum {DIR_MODE_PRINT_FS, DIR_MODE_PRINT_ROOT, DIR_MODE_PRINT_STREAMS};
enum {DIR_UNKNOWN, DIR_OK, DIR_INVALID_TOKEN};

static char token[9];
static SYS_FS_HANDLE dirHandle = SYS_FS_HANDLE_INVALID;
static SYS_FS_HANDLE fileHandle = SYS_FS_HANDLE_INVALID;

// table with the processed dynamic variables in this demo
static HTTP_APP_DYNVAR_ENTRY HTTP_APP_DynVarTbl[] = 
{
    // varName                      varFnc
    {"uptime",                      TCPIP_HTTP_Print_uptime},
	{"time",                        TCPIP_HTTP_Print_time},
	{"cpufreq",                     TCPIP_HTTP_Print_cpufreq},
	{"configToken",                 TCPIP_HTTP_Print_configToken},
	{"dhcpyes",						TCPIP_HTTP_Print_dhcpyes},
	{"dhcpno",                      TCPIP_HTTP_Print_dhcpno},
	{"ipdisp",						TCPIP_HTTP_Print_ipdisp},
	{"ip",							TCPIP_HTTP_Print_ip},
	{"mac",							TCPIP_HTTP_Print_mac},
	{"netmask",                     TCPIP_HTTP_Print_netmask},
	{"gw",                          TCPIP_HTTP_Print_gw},
	{"dns1",                        TCPIP_HTTP_Print_dns1},
	{"dns2",                        TCPIP_HTTP_Print_dns2},
	{"ntp",                         TCPIP_HTTP_Print_ntp},
	{"reset",                       TCPIP_HTTP_Print_reset},
	{"restore",                     TCPIP_HTTP_Print_restore},
	{"passChangeStatus",			TCPIP_HTTP_Print_passChangeStatus},
	{"configChangeStatus",			TCPIP_HTTP_Print_configChangeStatus},
	{"playStatus",					TCPIP_HTTP_Print_playStatus},
	{"parent",                      TCPIP_HTTP_Print_parent},
	{"dirs",                        TCPIP_HTTP_Print_dirs},
	{"files",                       TCPIP_HTTP_Print_files},
	{"playStatus",                  TCPIP_HTTP_Print_playStatus},
	{"playInfo",					TCPIP_HTTP_Print_playInfo},
//	{"status_ok",					TCPIP_HTTP_Print_status_ok},
//	{"ddns_status",					TCPIP_HTTP_Print_ddns_status},
//	{"ddns_status_msg",				TCPIP_HTTP_Print_ddns_status_msg},
//	{"ddns_service",				TCPIP_HTTP_Print_ddns_service},
//	{"ddns_user",					TCPIP_HTTP_Print_ddns_user},
//	{"ddns_pass",					TCPIP_HTTP_Print_ddns_pass},
//	{"ddns_host",					TCPIP_HTTP_Print_ddns_host},
};

// Function that processes the dynamic variables
// It uses the HTTP_APP_DynVarTbl[] for detecting which variable is currently processed
// and what function should be launched.
//
// Note: Again, this is just an example.
// Processing a large number of dynamic variables using this approach is highly inneficient
// and should be avoided.
// Better methods should be emplyed rather than linearly polling each variable name until the required name was found.
//
TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_NET_DynPrint(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt, const TCPIP_HTTP_NET_USER_CALLBACK *pCBack)
{
    int ix;
    HTTP_APP_DYNVAR_ENTRY *pEntry;

    // search for a dynamic variable name
    pEntry = HTTP_APP_DynVarTbl;
    for(ix = 0; ix < sizeof(HTTP_APP_DynVarTbl)/sizeof(*HTTP_APP_DynVarTbl); ++ix, ++pEntry)
    {
        if(strcmp(vDcpt->dynName, pEntry->varName) == 0)
        {   // found it
            return (*pEntry->varFnc)(connHandle, vDcpt);
        }
    }

    // not found; do nothing
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionGetExecute(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const struct _tag_TCPIP_HTTP_NET_USER_CALLBACK* pCBack) {
    uint8_t filename[64];
    
    // Load the file name
    // Make sure uint8_t filename[] above is large enough for your longest name
    filename[0] = 0;
    SYS_FS_FileNameGet(TCPIP_HTTP_NET_ConnectionFileGet(connHandle), filename, sizeof(filename));
    
    if (strncmp((const char*)filename, "www/ui/dir.json", sizeof(filename)) == 0) {
        return TCPIP_HTTP_NET_ConnectionGetDirJson(connHandle);
    }
    
    return TCPIP_HTTP_NET_IO_RES_DONE;
}

TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionGetDirJson(TCPIP_HTTP_NET_CONN_HANDLE connHandle) {
    const uint8_t *ptr;
    uint8_t *httpDataBuff;    
    httpDataBuff = TCPIP_HTTP_NET_ConnectionDataBufferGet(connHandle);
    ptr = TCPIP_HTTP_NET_ArgGet(httpDataBuff, (const uint8_t *)"url");
    if (ptr) {
        if ( (strncmp((const char*)ptr, "root", 5) == 0) || (strncmp((const char*)ptr, "/mnt/myDrive1", 14) == 0) ) {
            //parent = NULL;
            httpDataBuff[0] = DIR_OK;
            httpDataBuff[1] = DIR_MODE_PRINT_ROOT;
            return TCPIP_HTTP_NET_IO_RES_DONE;
        }
        else if (strncmp((const char*)ptr, "streams", 8) == 0) {
            //parent = NULL;
            httpDataBuff[0] = DIR_OK;
            httpDataBuff[1] = DIR_MODE_PRINT_STREAMS;
            uint16_t* streamInd = (uint16_t*)&httpDataBuff[4];
            *streamInd = 1;
            uint8_t* firstOne = (uint8_t*)&httpDataBuff[2];
            *firstOne = 1;
            return TCPIP_HTTP_NET_IO_RES_DONE;
        }
        else {
            char* parent = (char*)httpDataBuff+4;
            char tmpbuf[256];
            if (strncmp((const char*)ptr, "1:", 3) == 0) {
                strncpy(tmpbuf, "/mnt/myDrive0", sizeof(tmpbuf)-1);
            }
            else if (strncmp((const char*)ptr, "2:", 3) == 0) {
                strncpy(tmpbuf, "/mnt/myDrive1/music", sizeof(tmpbuf)-1);
            }
            else {
                strncpy(tmpbuf, (const char*)ptr, sizeof(tmpbuf)-1);
            }
            strncpy(parent, tmpbuf, TCPIP_HTTP_NET_ConnectionDataBufferSizeGet(connHandle)-5);
//            SYS_CONSOLE_PRINT("Parent: %s\r\n", parent);
            httpDataBuff[0] = DIR_OK;
            httpDataBuff[1] = DIR_MODE_PRINT_FS;
            return TCPIP_HTTP_NET_IO_RES_DONE;
        }
    }
    
    return TCPIP_HTTP_NET_IO_RES_DONE;
}

TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionPostExecute(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const struct _tag_TCPIP_HTTP_NET_USER_CALLBACK* pCBack) {
    // Resolve which function to use and pass along
    uint8_t filename[64];
    
    // Load the file name
    // Make sure uint8_t filename[] above is large enough for your longest name
    filename[0] = '\0';
    SYS_FS_FileNameGet(TCPIP_HTTP_NET_ConnectionFileGet(connHandle), filename, sizeof(filename));
    
    if( strncmp((const char*)filename, "www/ui/config.cgi", sizeof(filename)) == 0 ) {
        return TCPIP_HTTP_NET_ConnectionPostConfig(connHandle);
    }
    
    if( strncmp((const char*)filename, "www/ui/play.cgi", sizeof(filename)) == 0 ) {
        return TCPIP_HTTP_NET_ConnectionPostPlay(connHandle);
    }

    if( strncmp((const char*)filename, "www/ui/pass.cgi", sizeof(filename)) == 0 ) {
        return TCPIP_HTTP_NET_ConnectionPostPass(connHandle);
    }    
    
    return TCPIP_HTTP_NET_IO_RES_DONE;
}

TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionPostConfig(TCPIP_HTTP_NET_CONN_HANDLE connHandle) {
    enum {SM_READ_NAME = 0, SM_READ_VALUE, SM_DONE};
    typedef enum {NAME_UNKNOWN = 0, NAME_TOKEN, NAME_DHCP, NAME_IP, NAME_MAC, NAME_NETMASK, NAME_GW, NAME_DNS1, NAME_DNS2, NAME_NTP, NAME_TIMEZONE} varname_t;
    
    uint8_t *httpDataBuff;
    uint16_t httpBuffSize;    
    uint8_t smPost;
    static varname_t varname = NAME_UNKNOWN;
    
    httpDataBuff = TCPIP_HTTP_NET_ConnectionDataBufferGet(connHandle);
    httpBuffSize = TCPIP_HTTP_NET_ConnectionDataBufferSizeGet(connHandle);
    smPost = TCPIP_HTTP_NET_ConnectionPostSmGet(connHandle);
    switch (smPost) {
        case SM_READ_NAME:
            // If all parameters have been read, end
            if(TCPIP_HTTP_NET_ConnectionByteCountGet(connHandle) == 0u) {
                TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_DONE);
                break;
            }
            // Read a name
            if(TCPIP_HTTP_NET_ConnectionPostNameRead(connHandle, httpDataBuff, httpBuffSize) == TCPIP_HTTP_NET_READ_INCOMPLETE) {
                return TCPIP_HTTP_NET_IO_RES_NEED_DATA;
            }
            if (strncmp((const char*)httpDataBuff, "token", 6) == 0) {
                varname = NAME_TOKEN;
            }
            else if (strncmp((const char*)httpDataBuff, "dhcp", 4) == 0) {
                varname = NAME_DHCP;
            }
            else if (strncmp((const char*)httpDataBuff, "ip", 3) == 0) {
                varname = NAME_IP;
            }
            else if (strncmp((const char*)httpDataBuff, "mac", 4) == 0) {
                varname = NAME_MAC;
            }
            else if (strncmp((const char*)httpDataBuff, "netmask", 4) == 0) {
                varname = NAME_NETMASK;
            }
            else if (strncmp((const char*)httpDataBuff, "gw", 4) == 0) {
                varname = NAME_GW;
            }
            else if (strncmp((const char*)httpDataBuff, "dns1", 4) == 0) {
                varname = NAME_DNS1;
            }
            else if (strncmp((const char*)httpDataBuff, "dns2", 4) == 0) {
                varname = NAME_DNS2;
            }
            else if (strncmp((const char*)httpDataBuff, "ntp", 4) == 0) {
                varname = NAME_NTP;
            }
            else if (strncmp((const char*)httpDataBuff, "timezone", 4) == 0) {
                varname = NAME_TIMEZONE;
            }
            else {
                varname = NAME_UNKNOWN;
            }
            TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_READ_VALUE);         
            break;
        case SM_READ_VALUE:
            if(TCPIP_HTTP_NET_ConnectionPostValueRead(connHandle, httpDataBuff, httpBuffSize) == TCPIP_HTTP_NET_READ_INCOMPLETE) {
                return TCPIP_HTTP_NET_IO_RES_NEED_DATA;
            }
            switch (varname) {
                case NAME_TOKEN:
                    SYS_CONSOLE_PRINT("POSTConfig token, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_DHCP:
                    SYS_CONSOLE_PRINT("POSTConfig dhpc, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_IP:
                    SYS_CONSOLE_PRINT("POSTConfig ip, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_MAC:
                    SYS_CONSOLE_PRINT("POSTConfig mac, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_NETMASK:
                    SYS_CONSOLE_PRINT("POSTConfig netmash, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_GW:
                    SYS_CONSOLE_PRINT("POSTConfig gw, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_DNS1:
                    SYS_CONSOLE_PRINT("POSTConfig dns1, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_DNS2:
                    SYS_CONSOLE_PRINT("POSTConfig dns2, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_NTP:
                    SYS_CONSOLE_PRINT("POSTConfig ntp, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_TIMEZONE:
                    SYS_CONSOLE_PRINT("POSTConfig timezone, value: %s\r\n", (char *)httpDataBuff);
                    int new_time_zone = atoi((const char*)httpDataBuff) * -60;
                    if ( (new_time_zone < -780) || (new_time_zone > 660) ) {
                        httpDataBuff[0] = CFGCHANGE_INVALID_TIMEZONE;
                    }
                    else {
                        time_zone = new_time_zone;
                    }
                    break;
                default:
                    SYS_CONSOLE_PRINT("POSTConfig unknown parameter, value: %s\r\n", (char *)httpDataBuff);
                    break;
            }
            TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_READ_NAME);
            varname = NAME_UNKNOWN;
            break;
        case SM_DONE:
            return TCPIP_HTTP_NET_IO_RES_DONE;
            break;
        default:
            break;
    }
    
    return TCPIP_HTTP_NET_IO_RES_WAITING;
}

TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionPostPlay(TCPIP_HTTP_NET_CONN_HANDLE connHandle) {
    enum {SM_INIT = 0, SM_READ_NAME, SM_READ_VALUE, SM_DONE};
    typedef enum {NAME_UNKNOWN = 0, NAME_TOKEN, NAME_SRC, NAME_URL, NAME_VOL, NAME_LOOP} varname_t;
    typedef enum {PLAY_SRC_INVALID = 0, PLAY_SRC_STREAM, PLAY_SRC_FILE, PLAY_SRC_DIR, PLAY_SRC_ID} playsrc_t;
    
    uint8_t *httpDataBuff;
    uint16_t httpBuffSize;    
    uint8_t smPost;
    static varname_t varname = NAME_UNKNOWN;
    static playsrc_t playsrc = PLAY_SRC_INVALID;
    static char newtoken[9];
    static char newurl[1024];
    static uint8_t newVol = 0;
    static int8_t newLoop = -1;
    
    httpDataBuff = TCPIP_HTTP_NET_ConnectionDataBufferGet(connHandle);
    httpBuffSize = TCPIP_HTTP_NET_ConnectionDataBufferSizeGet(connHandle);
    smPost = TCPIP_HTTP_NET_ConnectionPostSmGet(connHandle);
    switch (smPost) {
        case SM_INIT:
            varname = NAME_UNKNOWN;
            playsrc = PLAY_SRC_INVALID;
            newVol = 0;
            newLoop = -1;
            memset(newtoken, 0x00, sizeof(newtoken));
            memset(newurl, 0x00, sizeof(newurl));
            TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_READ_NAME);
            //no break here
        case SM_READ_NAME:
            // If all parameters have been read, end
            if(TCPIP_HTTP_NET_ConnectionByteCountGet(connHandle) == 0u) {
                TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_DONE);
                break;
            }
            // Read a name
            if(TCPIP_HTTP_NET_ConnectionPostNameRead(connHandle, httpDataBuff, httpBuffSize) == TCPIP_HTTP_NET_READ_INCOMPLETE) {
                return TCPIP_HTTP_NET_IO_RES_NEED_DATA;
            }
            if (strncmp((const char*)httpDataBuff, "token", 6) == 0) {
                varname = NAME_TOKEN;
            }
            else if (strncmp((const char*)httpDataBuff, "src", 4) == 0) {
                varname = NAME_SRC;
            }
            else if (strncmp((const char*)httpDataBuff, "url", 4) == 0) {
                varname = NAME_URL;
            }
            else if (strncmp((const char*)httpDataBuff, "vol", 4) == 0) {
                varname = NAME_VOL;
            }
            else if (strncmp((const char*)httpDataBuff, "loop", 4) == 0) {
                varname = NAME_LOOP;
            }            
            else {
                varname = NAME_UNKNOWN;
            }
            TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_READ_VALUE);         
            break;
        case SM_READ_VALUE:
            if(TCPIP_HTTP_NET_ConnectionPostValueRead(connHandle, httpDataBuff, httpBuffSize) == TCPIP_HTTP_NET_READ_INCOMPLETE) {
                return TCPIP_HTTP_NET_IO_RES_NEED_DATA;
            }
            switch (varname) {
                case NAME_TOKEN:
                    SYS_CONSOLE_PRINT("POSTPlay token, value: %s\r\n", (char *)httpDataBuff);
                    strncpy(newtoken, (const char*)httpDataBuff, sizeof(newtoken)-1);
                    break;
                case NAME_SRC:
                    SYS_CONSOLE_PRINT("POSTPlay src, value: %s\r\n", (char *)httpDataBuff);
                    if (strncmp((const char*)httpDataBuff, "stream", 7) == 0) { playsrc = PLAY_SRC_STREAM; }
                    else if (strncmp((const char*)httpDataBuff, "file", 5) == 0) { playsrc = PLAY_SRC_FILE; }
                    else if (strncmp((const char*)httpDataBuff, "dir", 5) == 0) { playsrc = PLAY_SRC_DIR; }
                    else if (strncmp((const char*)httpDataBuff, "id", 5) == 0) { playsrc = PLAY_SRC_ID; }
                    else { playsrc = PLAY_SRC_INVALID; }
                    break;
                case NAME_URL:
                    SYS_CONSOLE_PRINT("POSTPlay url, value: %s\r\n", (char *)httpDataBuff);
                    strncpy(newurl, (const char*)httpDataBuff, sizeof(newurl)-1);
                    break;
                case NAME_VOL:
                    SYS_CONSOLE_PRINT("POSTPlay vol, value: %s\r\n", (char *)httpDataBuff);
                    newVol = strtol((char *)httpDataBuff, NULL, 10);
                    break;
                case NAME_LOOP:
                    SYS_CONSOLE_PRINT("POSTPlay loop, value: %s\r\n", (char *)httpDataBuff);
                    if (strncmp((char*)httpDataBuff, "true", 5) == 0) { newLoop = 1; }
                    else if (strncmp((char*)httpDataBuff, "false", 6) == 0) { newLoop = 0; }
                    else { newLoop = -1; }
                    break;
                default:
                    SYS_CONSOLE_PRINT("POSTPlay unknown parameter, value: %s\r\n", (char *)httpDataBuff);
                    break;
            }
            TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_READ_NAME);
            varname = NAME_UNKNOWN;
            break;
        case SM_DONE:
            //SYS_CONSOLE_PRINT("This is the end. Token is %s. Playsrc: %d, newurl: %s\r\n", (strncmp(token, newtoken, sizeof(token)) == 0) ? "valid" : "invalid", playsrc, newurl);
            if (strncmp(token, newtoken, sizeof(token)) != 0) {
                httpDataBuff[0] = PLAY_INVALID_TOKEN;
                SYS_CONSOLE_PRINT("POSTPlay: invalid token\r\n");
                return TCPIP_HTTP_NET_IO_RES_DONE;
            }
            SYS_CONSOLE_PRINT("POSTPlay: token ok\r\n");
            if (newVol) {
                VS1003_send_cmd_thread_safe(VS_MSG_SET_VOL, (uint32_t)newVol);
            }
            if (newLoop >= 0) {
                VS1003_send_cmd_thread_safe(VS_MSG_LOOP, newLoop);
            }
            if (strlen(newurl)) {
                if (strncmp(newurl, "stop", 5) == 0) {
                    SYS_CONSOLE_PRINT("POSTPlay: stop\r\n");
                    VS1003_send_cmd_thread_safe(VS_MSG_STOP, 0);
                }
                else if (strncmp(newurl, "next", 5) == 0) {
                    SYS_CONSOLE_PRINT("POSTPlay: playing next song/stream\r\n");
                     VS1003_send_cmd_thread_safe(VS_MSG_NEXT, 0);
                }
                else if (strncmp(newurl, "prev", 5) == 0) {
                    SYS_CONSOLE_PRINT("POSTPlay: playing prev song/stream\r\n");
                    VS1003_send_cmd_thread_safe(VS_MSG_PREV, 0);
                }
                else {
                    switch(playsrc) {
                        case PLAY_SRC_FILE:
                            if (!is_local_url_valid(newurl)) {
                                httpDataBuff[0] = PLAY_INVALID_URL;
                                break;
                            }
                            SYS_CONSOLE_PRINT("POSTPlay: playing file %s\r\n", newurl);
                            VS1003_send_cmd_thread_safe(VS_MSG_PLAY_FILE, (uint32_t)newurl);
                            break;
                        case PLAY_SRC_DIR:
                            if (!is_local_url_valid(newurl)) {
                                httpDataBuff[0] = PLAY_INVALID_URL;
                                break;
                            }                            
                            SYS_CONSOLE_PRINT("POSTPlay: playing dir %s\r\n", newurl);
                            VS1003_send_cmd_thread_safe(VS_MSG_PLAY_DIR, (uint32_t)newurl);
                            break;
                        case PLAY_SRC_ID:;
                            uint16_t streamid = strtol(newurl, NULL, 10);
                            SYS_CONSOLE_PRINT("POSTPlay: playing stream by id %d\r\n", streamid);
                            VS1003_send_cmd_thread_safe(VS_MSG_PLAY_STREAM_BY_ID, streamid);
                            break;
                        default:
                            break;
                    }
                }
            }
            httpDataBuff[0] = PLAY_OK;
            return TCPIP_HTTP_NET_IO_RES_DONE;
            break;
        default:
            break;
    }
    
    return TCPIP_HTTP_NET_IO_RES_WAITING;
}

TCPIP_HTTP_NET_IO_RESULT TCPIP_HTTP_NET_ConnectionPostPass(TCPIP_HTTP_NET_CONN_HANDLE connHandle) {
    enum {SM_READ_NAME = 0, SM_READ_VALUE, SM_DONE};
    typedef enum {NAME_UNKNOWN = 0, NAME_TOKEN, NAME_OLDPASS, NAME_NEWPASS} varname_t;
    
    uint8_t *httpDataBuff;
    uint16_t httpBuffSize;    
    uint8_t smPost;
    static varname_t varname = NAME_UNKNOWN;
    
    httpDataBuff = TCPIP_HTTP_NET_ConnectionDataBufferGet(connHandle);
    httpBuffSize = TCPIP_HTTP_NET_ConnectionDataBufferSizeGet(connHandle);
    smPost = TCPIP_HTTP_NET_ConnectionPostSmGet(connHandle);
    switch (smPost) {
        case SM_READ_NAME:
            // If all parameters have been read, end
            if(TCPIP_HTTP_NET_ConnectionByteCountGet(connHandle) == 0u) {
                TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_DONE);
                break;
            }
            // Read a name
            if(TCPIP_HTTP_NET_ConnectionPostNameRead(connHandle, httpDataBuff, httpBuffSize) == TCPIP_HTTP_NET_READ_INCOMPLETE) {
                return TCPIP_HTTP_NET_IO_RES_NEED_DATA;
            }
            if (strncmp((const char*)httpDataBuff, "token", 6) == 0) {
                varname = NAME_TOKEN;
            }
            else if (strncmp((const char*)httpDataBuff, "oldpass", 4) == 0) {
                varname = NAME_OLDPASS;
            }
            else if (strncmp((const char*)httpDataBuff, "newpass", 3) == 0) {
                varname = NAME_NEWPASS;
            }
            else {
                varname = NAME_UNKNOWN;
            }
            TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_READ_VALUE);         
            break;
        case SM_READ_VALUE:
            if(TCPIP_HTTP_NET_ConnectionPostValueRead(connHandle, httpDataBuff, httpBuffSize) == TCPIP_HTTP_NET_READ_INCOMPLETE) {
                return TCPIP_HTTP_NET_IO_RES_NEED_DATA;
            }
            switch (varname) {
                case NAME_TOKEN:
                    SYS_CONSOLE_PRINT("POSTPass token, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_OLDPASS:
                    SYS_CONSOLE_PRINT("POSTPass oldpass, value: %s\r\n", (char *)httpDataBuff);
                    break;
                case NAME_NEWPASS:
                    SYS_CONSOLE_PRINT("POSTPass newpass, value: %s\r\n", (char *)httpDataBuff);
                    break;
                default:
                    SYS_CONSOLE_PRINT("POSTPass unknown parameter, value: %s\r\n", (char *)httpDataBuff);
                    break;
            }
            TCPIP_HTTP_NET_ConnectionPostSmSet(connHandle, SM_READ_NAME);
            varname = NAME_UNKNOWN;
            break;
        case SM_DONE:
            return TCPIP_HTTP_NET_IO_RES_DONE;
            break;
        default:
            break;
    }
    
    return TCPIP_HTTP_NET_IO_RES_WAITING;
}

uint8_t TCPIP_HTTP_NET_ConnectionFileAuthenticate(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const char* cFile, const struct _tag_TCPIP_HTTP_NET_USER_CALLBACK* pCBack) {
    if (strncmp(cFile, "ui/", 3) == 0) return 0x00;
    return 0x80;   //TODO
}

uint8_t TCPIP_HTTP_NET_ConnectionUserAuthenticate(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const char* cUser, const char* cPass, const struct _tag_TCPIP_HTTP_NET_USER_CALLBACK* pCBack) {
    if ( (strncmp(cUser, "admin", 5) == 0) && (strncmp(cPass, "s3cr3t", 6) == 0) ) return 0x80;
    return 0;   //TODO
}

void TCPIP_HTTP_NET_DynAcknowledge(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const void* buffer, const struct _tag_TCPIP_HTTP_NET_USER_CALLBACK* pCBack) {
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = (HTTP_APP_DYNVAR_BUFFER*)((const uint8_t *)buffer - offsetof(struct HTTP_APP_DYNVAR_BUFFER, data));
    pDynBuffer->busy = 0;
}

void TCPIP_HTTP_NET_EventReport(TCPIP_HTTP_NET_CONN_HANDLE connHandle, TCPIP_HTTP_NET_EVENT_TYPE evType, const void* evInfo, const struct _tag_TCPIP_HTTP_NET_USER_CALLBACK* pCBack) {
    const char *evMsg = (const char *)evInfo;

    if(evType < 0)
    {   // display errors only
        if(evMsg == 0)
        {
            evMsg = "none";
        }
        SYS_CONSOLE_PRINT("HTTP event: %d, info: %s\r\n", evType, evMsg);
    }
}

bool TCPIP_HTTP_NET_SSINotification(TCPIP_HTTP_NET_CONN_HANDLE connHandle, TCPIP_HTTP_SSI_NOTIFY_DCPT* pSSINotifyDcpt, const struct _tag_TCPIP_HTTP_NET_USER_CALLBACK* pCBack) {
    return false;
}

static HTTP_APP_DYNVAR_BUFFER httpDynVarBuffers[HTTP_APP_DYNVAR_BUFFERS_NO];

// helper to get one of the application's dynamic buffer that are used in the
// dynamic variables processing
HTTP_APP_DYNVAR_BUFFER *HTTP_APP_GetDynamicBuffer(void)
{
    int ix;
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer;

    pDynBuffer = httpDynVarBuffers;
    for(ix = 0; ix < sizeof(httpDynVarBuffers)/sizeof(*httpDynVarBuffers); ++ix, pDynBuffer++)
    {
        if(pDynBuffer->busy == 0)
        {
            pDynBuffer->busy = 1;
            return pDynBuffer;
        }
    }
    return 0;
}

/****************************************************************************
  Section:
    Application initialization and HTTP registration.
    Here the application registers with the HTTP module the functions
    that will process the HTTP events (dynamic variables, SSI events, Post, Get, etc.).
    Note that without registering the process functions with HTTP, there won't be any web page processing.
    There is no default processing for a web page!

    See http_net_print.h for details regarding each of these functions.
 ****************************************************************************/
void HTTP_APP_Initialize(void)
{
    int ix;
    

    for(ix = 0; ix < sizeof(httpDynVarBuffers)/sizeof(*httpDynVarBuffers); ++ix)
    {
        httpDynVarBuffers[ix].busy = 0;
        httpDynVarBuffers[ix].bufferSize = HTTP_APP_DYNVAR_BUFFER_SIZE;
    }

    TCPIP_HTTP_NET_USER_CALLBACK appHttpCBack =
    {
        .getExecute = TCPIP_HTTP_NET_ConnectionGetExecute,              // Process the "GET" command
        .postExecute = TCPIP_HTTP_NET_ConnectionPostExecute,            // Process the "POST" command
        .fileAuthenticate = TCPIP_HTTP_NET_ConnectionFileAuthenticate,  // Process the file authentication
        .userAuthenticate = TCPIP_HTTP_NET_ConnectionUserAuthenticate,  // Process the user authentication

        .dynamicPrint = TCPIP_HTTP_NET_DynPrint,                        // Process the dynamic variable callback
        .dynamicAck = TCPIP_HTTP_NET_DynAcknowledge,                    // Acknowledgment function for when the dynamic variable processing is completed
        .eventReport = TCPIP_HTTP_NET_EventReport,                      // HTTP Event notification callback

        .ssiNotify = TCPIP_HTTP_NET_SSINotification,                    // SSI command calback
    };

    TCPIP_HTTP_NET_USER_HANDLE httpH = TCPIP_HTTP_NET_UserHandlerRegister(&appHttpCBack);
    if(httpH == 0)
    {
        SYS_CONSOLE_MESSAGE("APP: Failed to register the HTTP callback!\r\n");
    }
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_dhcpyes(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    TCPIP_NET_HANDLE hNet;
    hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    if (TCPIP_DNS_IsEnabled(hNet)) {
        TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "checked", false);
    }
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_dhcpno(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    TCPIP_NET_HANDLE hNet;
    hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    if (!TCPIP_DNS_IsEnabled(hNet)) {
        TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "checked", false);
    }
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_ipdisp(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    TCPIP_NET_HANDLE hNet;
    hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    if (TCPIP_DNS_IsEnabled(hNet)) {
        TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "none", false);
    }
    else {
        TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "block", false);
    }
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;    
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_ip(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    IPV4_ADDR ipAddress;
    char *ipAddStr;
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }

    ipAddStr = pDynBuffer->data;
    TCPIP_NET_HANDLE hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    ipAddress.Val = TCPIP_STACK_NetAddress(hNet);

    TCPIP_Helper_IPAddressToString(&ipAddress, ipAddStr, HTTP_APP_DYNVAR_BUFFER_SIZE);
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, ipAddStr, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;   
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_mac(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    TCPIP_NET_HANDLE hNet;
    const TCPIP_MAC_ADDR *pMacAdd;
    char macAddStr[20];
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer;

    hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    pMacAdd = (const TCPIP_MAC_ADDR*)TCPIP_STACK_NetAddressMac(hNet);
    if(pMacAdd && sizeof(pDynBuffer->data) > sizeof(macAddStr))
    {
        TCPIP_Helper_MACAddressToString(pMacAdd, macAddStr, sizeof(macAddStr));
        pDynBuffer = HTTP_APP_GetDynamicBuffer();
        if(pDynBuffer == 0)
        {   // failed to get a buffer; retry
            return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
        }
        strncpy(pDynBuffer->data, macAddStr, sizeof(macAddStr) - 1);
        pDynBuffer->data[sizeof(macAddStr) - 1] = 0;
        TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
    }
    else
    {
        TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "Failed to get a MAC address", false);
    }

    return TCPIP_HTTP_DYN_PRINT_RES_DONE; 
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_netmask(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    IPV4_ADDR ipMask;
    char *ipAddStr;
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }

    ipAddStr = pDynBuffer->data;
    TCPIP_NET_HANDLE hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    ipMask.Val = TCPIP_STACK_NetMask(hNet);
    TCPIP_Helper_IPAddressToString(&ipMask, ipAddStr, HTTP_APP_DYNVAR_BUFFER_SIZE);
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, ipAddStr, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_gw(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    IPV4_ADDR gwAddress;
    char *ipAddStr;
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }

    ipAddStr = pDynBuffer->data;
    TCPIP_NET_HANDLE hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    gwAddress.Val = TCPIP_STACK_NetAddressGateway(hNet);
    TCPIP_Helper_IPAddressToString(&gwAddress, ipAddStr, HTTP_APP_DYNVAR_BUFFER_SIZE);
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, ipAddStr, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_dns1(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    IPV4_ADDR priDnsAddr;
    char *ipAddStr;
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }

    ipAddStr = pDynBuffer->data;
    TCPIP_NET_HANDLE hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    priDnsAddr.Val = TCPIP_STACK_NetAddressDnsPrimary(hNet);
    TCPIP_Helper_IPAddressToString(&priDnsAddr, ipAddStr, HTTP_APP_DYNVAR_BUFFER_SIZE);
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, ipAddStr, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_dns2(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    IPV4_ADDR secondDnsAddr;
    char *ipAddStr;
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }

    ipAddStr = pDynBuffer->data;

    TCPIP_NET_HANDLE hNet = TCPIP_HTTP_NET_ConnectionNetHandle(connHandle);
    secondDnsAddr.Val = TCPIP_STACK_NetAddressDnsSecond(hNet);
    TCPIP_Helper_IPAddressToString(&secondDnsAddr, ipAddStr, HTTP_APP_DYNVAR_BUFFER_SIZE);
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, ipAddStr, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_ntp(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, TCPIP_NTP_SERVER, false);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_reset(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_restore(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_passChangeStatus(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_configChangeStatus(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_parent(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    uint8_t* httpDataBuff = TCPIP_HTTP_NET_ConnectionDataBufferGet(connHandle);
    switch (httpDataBuff[1]) {
        case DIR_MODE_PRINT_ROOT:
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "root", false);
            break;
        case DIR_MODE_PRINT_STREAMS:
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "streams", false);
            break;
        case DIR_MODE_PRINT_FS:;
            char* parent = (char*)httpDataBuff+4;
            if (strlen(parent) == 0) return TCPIP_HTTP_DYN_PRINT_RES_DONE;
            HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
            if(pDynBuffer == 0) { 
                // failed to get a buffer; retry
                return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
            }
             strncpy(pDynBuffer->data, parent, HTTP_APP_DYNVAR_BUFFER_SIZE);
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
            break;
        default:
            break;        
    }
    
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_dirs(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    uint8_t* httpDataBuff  = TCPIP_HTTP_NET_ConnectionDataBufferGet(connHandle);
    uint8_t* firstOne = (uint8_t*)&httpDataBuff[2];
    switch (httpDataBuff[1]) {    
        case DIR_MODE_PRINT_ROOT:
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "\"1:\", \"2:\", \"streams\"", false);
            break;
        case DIR_MODE_PRINT_STREAMS:
            break;
        case DIR_MODE_PRINT_FS:
            if (TCPIP_HTTP_NET_ConnectionCallbackPosGet(connHandle) == 0) {
                char* parent = (char*)httpDataBuff+4;
                if (strlen(parent) == 0) return TCPIP_HTTP_DYN_PRINT_RES_DONE;
                if (dirHandle != SYS_FS_HANDLE_INVALID) {
                    return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
                }    
                dirHandle = SYS_FS_DirOpen(parent);
                if (dirHandle == SYS_FS_HANDLE_INVALID) {
                    SYS_CONSOLE_PRINT("Can't open dir!\r\n");
                    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
                }
                *firstOne = 1;
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x01);
                return TCPIP_HTTP_DYN_PRINT_RES_DONE;                
            }
            SYS_FS_FSTAT stat;
            char longFileName[300];
            stat.lfname = longFileName;
            stat.lfsize = 300;
            if (SYS_FS_DirRead(dirHandle, &stat) == SYS_FS_RES_FAILURE) {
                SYS_CONSOLE_PRINT("Can't read dir\r\n");
                SYS_FS_DirClose(dirHandle);
                dirHandle = SYS_FS_HANDLE_INVALID;
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x00);
                return TCPIP_HTTP_DYN_PRINT_RES_DONE;
            }
            if (stat.fname[0]) {
                if (stat.fattrib & AM_DIR) {
                    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
                    if(pDynBuffer == 0) { 
                        // failed to get a buffer; retry
                        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
                    }
                    size_t res = snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "%s{\"ln\":\"%s\",\"sn\":\"%s\"}", *firstOne ? "" : ", ", stat.fname, get_altname_if_available(&stat));
                    if (res >= HTTP_APP_DYNVAR_BUFFER_SIZE) {
                        SYS_CONSOLE_PRINT("DynPrintBuffer not large enough.\r\n");
                    }
                    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
                    *firstOne = 0;
                }
            }
            else {
                SYS_FS_DirClose(dirHandle);
                dirHandle = SYS_FS_HANDLE_INVALID;
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x00);
                return TCPIP_HTTP_DYN_PRINT_RES_DONE;
            }            
            break;
        default:
            break;        
    }
    
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_files(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    uint8_t* httpDataBuff = TCPIP_HTTP_NET_ConnectionDataBufferGet(connHandle);
    uint8_t* firstOne = (uint8_t*)&httpDataBuff[2];
    switch (httpDataBuff[1]) { 
        case DIR_MODE_PRINT_ROOT:
            break;
        case DIR_MODE_PRINT_STREAMS:;
            if (TCPIP_HTTP_NET_ConnectionCallbackPosGet(connHandle) == 0) {
                if (fileHandle != SYS_FS_HANDLE_INVALID) {
                    return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
                }
                fileHandle = SYS_FS_FileOpen(STREAM_LIST_PATH, SYS_FS_FILE_OPEN_READ);
                if (fileHandle == SYS_FS_HANDLE_INVALID) {
                    SYS_CONSOLE_PRINT("Can't open radio.txt file!\r\n");
                    return TCPIP_HTTP_DYN_PRINT_RES_DONE;                    
                }
//                SYS_CONSOLE_PRINT("radio.txt file opened, handle: %lu\r\n", fileHandle);
                *firstOne = 1;
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x01);
            }
            char line[512];
            // Save current file position
            int32_t current_file_pos = SYS_FS_FileTell(fileHandle);
            if (SYS_FS_FileStringGet(fileHandle, line, sizeof(line)-1) == SYS_FS_RES_SUCCESS) {
                if (line[strlen(line)-1] == '\n') {
                    line[strlen(line)-1] = '\0';
                }
                char name[64];    
                char url[256];
                int id = TCPIP_HTTP_NET_ConnectionCallbackPosGet(connHandle);
                if (parse_stream_data_line(line, strlen(line), name, sizeof(name), url, sizeof(url))) {
                    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
                    if(pDynBuffer == 0) { 
                        // failed to get a buffer; retry
                        // Restore old position to try again
                        if (current_file_pos >= 0) {
                            SYS_FS_FileSeek(fileHandle, current_file_pos, SYS_FS_SEEK_SET);
                        }
                        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
                    }
                    snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "%s{\"id\": \"%d\", \"name\": \"%s\", \"url\": \"%s\"}", *firstOne ? "" : ", ", id, name, url);
                    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
                    *firstOne = 0;                
                }
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, id+1);
            }
            else {
                SYS_FS_FileClose(fileHandle);
                fileHandle = SYS_FS_HANDLE_INVALID;
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x00);
                return TCPIP_HTTP_DYN_PRINT_RES_DONE;
            }
            break;
        case DIR_MODE_PRINT_FS:;
            if (TCPIP_HTTP_NET_ConnectionCallbackPosGet(connHandle) == 0) {
                char* parent = (char*)httpDataBuff+4;
                if (strlen(parent) == 0) return TCPIP_HTTP_DYN_PRINT_RES_DONE;
                if (dirHandle != SYS_FS_HANDLE_INVALID) {
                    return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
                }
                dirHandle = SYS_FS_DirOpen(parent);
                if (dirHandle == SYS_FS_HANDLE_INVALID) {
                    SYS_CONSOLE_PRINT("Can't open dir!\r\n");
                    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
                }
//                SYS_CONSOLE_PRINT("Dir opened, handle: %lu\r\n", dirHandle);
                *firstOne = 1;
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x01);
                return TCPIP_HTTP_DYN_PRINT_RES_DONE;
            }
            SYS_FS_FSTAT stat;
            char longFileName[300];
            stat.lfname = longFileName;
            stat.lfsize = 300;
            if (SYS_FS_DirRead(dirHandle, &stat) == SYS_FS_RES_FAILURE) {
                SYS_CONSOLE_PRINT("Can't read dir\r\n");
                SYS_FS_DirClose(dirHandle);
                dirHandle = SYS_FS_HANDLE_INVALID;
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x00);
                return TCPIP_HTTP_DYN_PRINT_RES_DONE;
            }
            if (stat.fname[0]) {
                if (is_audio_file(stat.fname)) {
                    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
                    if(pDynBuffer == 0) { 
                        // failed to get a buffer; retry
                        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
                    }
                    size_t res = snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "%s{\"ln\":\"%s\",\"sn\":\"%s\"}", *firstOne ? "" : ", ", stat.fname, get_altname_if_available(&stat));
                    if (res >= HTTP_APP_DYNVAR_BUFFER_SIZE) {
                        SYS_CONSOLE_PRINT("DynPrintBuffer not large enough.\r\n");
                    }
                    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
                    *firstOne = 0;
                }
            }
            else {
                SYS_FS_DirClose(dirHandle);
                dirHandle = SYS_FS_HANDLE_INVALID;
                TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x00);
                return TCPIP_HTTP_DYN_PRINT_RES_DONE;
            }
            break;
        default:
            break; 
    }
    
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_playStatus(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    uint8_t *httpDataBuff = TCPIP_HTTP_NET_ConnectionDataBufferGet(connHandle);
    switch (httpDataBuff[0]) {
        case PLAY_OK:
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "ok", false);
            break;
        case PLAY_INVALID_TOKEN:
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "invalid_token", false);
            break;
        case PLAY_INVALID_URL:
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "invalid_url", false);
            break;
        default:
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, "unknown_error", false);
            break;
    }
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_playInfo(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    enum {INFO_VOLUME=0, INFO_LOOP, INFO_TYPE, INFO_ARTIST, INFO_TITLE, INFO_GENRE};
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer;
    int state;
    state = TCPIP_HTTP_NET_ConnectionCallbackPosGet(connHandle);
    
    switch(state) {
        case INFO_VOLUME:
            pDynBuffer = HTTP_APP_GetDynamicBuffer();
            if(pDynBuffer == 0)
            {   // failed to get a buffer; retry
                return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
            }
            snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "{\"volume\": \"%d\", ", VS1003_getVolume());
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
            TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, INFO_LOOP);
            break;
        case INFO_LOOP:
            pDynBuffer = HTTP_APP_GetDynamicBuffer();
            if(pDynBuffer == 0)
            {   // failed to get a buffer; retry
                return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
            }
            snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "\"loop\": \"%s\", ", VS1003_getLoop() ? "true" : "false");
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
            TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, INFO_TYPE);
            break;
        case INFO_TYPE:
            pDynBuffer = HTTP_APP_GetDynamicBuffer();
            if(pDynBuffer == 0)
            {   // failed to get a buffer; retry
                return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
            }
            snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "\"type\": \"%s\", ", (mediainfo_type_get() == MEDIA_TYPE_STREAM) ? "stream" : "file" );
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
            TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, INFO_ARTIST);            
            break;
        case INFO_ARTIST:
            pDynBuffer = HTTP_APP_GetDynamicBuffer();
            if(pDynBuffer == 0)
            {   // failed to get a buffer; retry
                return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
            }
            snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "\"artist\": \"%s\", ", mediainfo_artist_get());
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
            TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, INFO_TITLE);            
            break;
        case INFO_TITLE:
            pDynBuffer = HTTP_APP_GetDynamicBuffer();
            if(pDynBuffer == 0)
            {   // failed to get a buffer; retry
                return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
            }
            snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "\"title\": \"%s\", ", mediainfo_title_get());
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
            TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, INFO_GENRE);            
            break;
        case INFO_GENRE:
            pDynBuffer = HTTP_APP_GetDynamicBuffer();
            if(pDynBuffer == 0)
            {   // failed to get a buffer; retry
                return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
            }
            snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "\"genre\": \"%s\"}", mediainfo_genre_get());
            TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
            TCPIP_HTTP_NET_ConnectionCallbackPosSet(connHandle, 0x00);            
            break;
        default:
            break;
    }
    
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_uptime(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }

    uint16_t days, hours, minutes;
    uint32_t seconds;
    char support_buff[16];
    
    seconds = uptime();
    days = seconds / 86400;
    seconds -= days * 86400;
    hours = seconds / 3600;
    seconds -= hours * 3600;
    minutes = seconds / 60;
    seconds -= minutes * 60;

    if (days) {
        snprintf(support_buff, sizeof(support_buff)-1, "%d dni, ", days);
    }
    
    snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "%s%02d:%02d:%02d", days ? support_buff : "", hours, minutes, seconds);
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_time(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }
    time_t timestamp = time(NULL);
    strncpy(pDynBuffer->data, ctime(&timestamp), HTTP_APP_DYNVAR_BUFFER_SIZE);   
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_cpufreq(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }
    snprintf(pDynBuffer->data, HTTP_APP_DYNVAR_BUFFER_SIZE, "%d MHz", CPU_CLOCK_FREQUENCY/1000000);
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

TCPIP_HTTP_DYN_PRINT_RES TCPIP_HTTP_Print_configToken(TCPIP_HTTP_NET_CONN_HANDLE connHandle, const TCPIP_HTTP_DYN_VAR_DCPT *vDcpt) {
    uint8_t i;
 
    HTTP_APP_DYNVAR_BUFFER *pDynBuffer = HTTP_APP_GetDynamicBuffer();
    if(pDynBuffer == 0)
    {   // failed to get a buffer; retry
        return TCPIP_HTTP_DYN_PRINT_RES_AGAIN;
    }
    for (i=0; i<8; i++) token[i] = 'a'+(rand() % 26);
    token[8] = '\0';
    strncpy(pDynBuffer->data, token, HTTP_APP_DYNVAR_BUFFER_SIZE);
    TCPIP_HTTP_NET_DynamicWriteString(vDcpt, pDynBuffer->data, true);
    return TCPIP_HTTP_DYN_PRINT_RES_DONE;
}

static bool is_local_url_valid(const char* url) {
    if ( (strstr(url, "/mnt/myDrive0") == url) || (strstr(url, "/mnt/myDrive1/music") == url) ) {
        return true;
    }
    return false;
}

const char* get_altname_if_available(SYS_FS_FSTAT* stat) {
    if (strlen(stat->altname)) {
        return stat->altname;
    }
    else if (strlen(stat->fname) <= 12) {
        return stat->fname;
    }
    return "";
}